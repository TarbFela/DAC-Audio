//
// Created by The Tragedy of Darth Wise on 12/29/24.
//

#include "pitch_analysis.h"

#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>


// frequencies of C2 to B2
const int PITCH_FREQS[12] = {  65, 69, 73, 78,
                               82, 87, 93, 98,
                               104, 110, 117, 123 };

FREQ_ANALYZER_T *init_freq_analyzer(uint16_t *audio_buff, uint32_t buff_size, uint32_t sample_rate, uint32_t correlation_threshhold) {
    FREQ_ANALYZER_T *s;
    s = (FREQ_ANALYZER_T *)malloc(sizeof(FREQ_ANALYZER_T));
    s->buff_size = buff_size;
    s->audio_buffer = audio_buff;
    // number of correlations is (half_size + 1)
    s->corrs_arr_size = buff_size / 2 + 1;
    s->correlations_array = (uint32_t *)malloc( s->corrs_arr_size * sizeof(uint32_t));
    s->sample_rate = sample_rate;
    return s;
}
// find the frequency of some audio in Hz using a version of the Yin pitch detection algorithm
// Errors:
//    0: no frequency met the correlation threshhold. This is useful for loud indiscriminate sounds
//    -1: bad arguments
//    -2: malloc failed (damn you, malloc!)

// TODO: re-organize the passed info into a typedef struct
void calculate_yin(FREQ_ANALYZER_T *s) {
    uint32_t carr_size = s->corrs_arr_size;

    uint32_t tau;

    // note: uint32_t goes up to 4.3 billion. The highest correlations
    // I've seen so far with buffer sizes this big are around 5 million,
    // so this could be an int overflow hazard but seems safe for now.

    uint32_t *corrs = s->correlations_array;
    //corrs = (uint32_t *) malloc( (half_size + 1) * sizeof(uint32_t)  );
    uint32_t abs_min_corrs = 100; //used to differentiate harmonics from root-copy-artifacts generated by Yin

    uint16_t *buff = s->audio_buffer;

    uint32_t cum_avg = 1;


    for( tau = 0; tau < carr_size; tau++) {
        corrs[tau] = 0;
        // CORRELATION CALCULATION
        for( int sample = 0; sample < carr_size; sample ++) {
            int diff = (int)(buff[sample] - buff[sample+tau]);
            uint32_t diff_squared = diff*diff;
            corrs[tau] += diff_squared;
        }
        // NORMALIZATION (averaging)
        if(tau == 0) cum_avg = corrs[tau];
        else {
            cum_avg = (cum_avg * (tau - 1) + corrs[tau]) / tau;
            corrs[tau] = CORR_INT_SCALAR * corrs[tau] / cum_avg;
            //printf("freq: %7.0d, cumavg: %10.0d, corr_norm: %7.0d", (int)(sample_rate/tau), cum_avg, corrs[tau]);
            abs_min_corrs = (corrs[tau] < abs_min_corrs) ? corrs[tau] : abs_min_corrs;
        }
    }
    /*
    // FIND THE LOWEST FREQUENCY TROUGH
    // Considerations:
    // (1) High Tau = Low Frequency
    // (2) Audio with a frequency "f" will produce peaks at corrs[f], corrs[2f], corrs[3f]...
    // (3) The actual corrs curve is **not smooth**
    // Method: A trough is characterized by falling and then rising
    // (1) We will start from our highest tau (lowest frequency) and increment up
    // (2) We will keep track of the running minimum
    // (3) If we're going down a trough, we will be very close to our most recent minimum
    // (4) If we're going up a trough, we will be further from our minimum
    // (5) So if our corrs[tau] is much bigger than our minimum, we'll know we reached the local minimum a little while back
    // (6) it's also good to check that our local min was withing the correlation threshhold in the first place
    uint32_t corrs_min = CORR_INT_SCALAR; //biggest (good) normalized corr value
    int corrs_min_index = -1; // -1 is a "nothing found" marker
    for( tau = half_size - 1; tau >= min_tau; tau--) { //big tau --> small tau :: low freq --> high freq
        //if(corrs[tau] > CORR_INT_SCALAR) continue; // skip bad values
        if(corrs[tau] < corrs_min && corrs[tau] < correlation_threshhold) { //min update (only on low enough values)
            corrs_min = corrs[tau];
            corrs_min_index = tau;
        } else if(corrs[tau] - TROUGH_THRESHHOLD > corrs_min) break; // if we've gone back up enough, break
    }
    int tau_out = corrs_min_index;
     */
    // Idea number 2:
    // Figure out the min corr from the corr calc loop
    // Use that as a dynamic correlation threshhold to differentiate harmonics from root-copies
    // Iterate downward from our max freq (min tau) until we get close to our dynamic threshhold

    // State machine: Get to our trough, find a minimum within that trough

    /*
    uint32_t loc_min = 1000; //big number
    int latch = 0;
    for( tau = 1; tau < carr_size - 1; tau++) {
        if( latch == 0 && corrs[tau] - abs_min_corrs < 10) latch = 1;
        else if (latch) {
            if (corrs[tau] < loc_min) loc_min = corrs[tau];
            else break;
        }
    }



    //free(corrs); // oopsies don't want a memory leak now, do we?

    //if(min_corr_tau == -1) return 0;
    if(abs_min_corrs > s->correlation_threshhold) return 0;
    return s->sample_rate / tau;
     */
}

int find_dominant_tau(FREQ_ANALYZER_T *s, int n_taus, uint32_t *test_tau_array) {
    uint32_t *corrs = s->correlations_array;

    for(int i = 0; i < n_taus; i++) {
        // test tau (reverse order from large to small
        uint32_t tt = test_tau_array[n_taus - i];
        if(corrs[tt] < TROUGH_THRESHHOLD) return tt;
    }
    return -1; // nothing was strongly correlated enough
}

#define TAU_INTERP_SCALAR 1000 // should be **plenty**
#define LOC_MIN_UP_THRESH 1 // the amount by which the curve can come back up before the local minimum is logged
#define LOC_MAX_MIN 20 // the threshold for a minimum to qualify.
typedef enum {
    START,
    TROUGH,
    DONE
} loc_min_state_t;

int dominant_freq(FREQ_ANALYZER_T *s) {
    uint32_t *corrs = s->correlations_array;

    // find the minimum
    loc_min_state_t state = START;
    uint32_t loc_min_val = CORR_INT_SCALAR;
    uint32_t loc_min_tau = 0;
    int tau;
    for(tau = 20; tau < s->corrs_arr_size; tau++) {
        if (corrs[tau] < loc_min_val) {
            loc_min_val = corrs[tau];
            loc_min_tau = tau;
        }
        switch (state) {
            case START:
                if (corrs[tau] < LOC_MAX_MIN) {state = TROUGH;}
                break;
            case TROUGH:
                if (corrs[tau] > loc_min_val + LOC_MIN_UP_THRESH) {state = DONE;}
                break;
        }
        if (state == DONE) break;
    }
    if (state != DONE) return -1; // no freq found. Sad.
    int freq = (s->sample_rate) / (loc_min_tau);
    return freq;
}
int dominant_freq_interpolating(FREQ_ANALYZER_T *s) {
    /*
     * Steps:
     *      (1) Find a local minimum with a state machine
     *      (2) Apply a weighted guess to interpolate between a min and its neighbors (see README)
     *              x_0 â‰ˆ x_min + tau_step * (a-b) / 2(a+b+1)
     */

    uint32_t *corrs = s->correlations_array;

    // find the minimum
    loc_min_state_t state = START;
    uint32_t loc_min_val = CORR_INT_SCALAR;
    uint32_t loc_min_tau = 0;
    int tau;
    for(tau = 20; tau < s->corrs_arr_size; tau++) {
        if (corrs[tau] < loc_min_val) {
            loc_min_val = corrs[tau];
            loc_min_tau = tau;
        }
        switch (state) {
            case START:
                if (corrs[tau] < LOC_MAX_MIN) {state = TROUGH;}
                break;
            case TROUGH:
                if (corrs[tau] > loc_min_val + LOC_MIN_UP_THRESH) {state = DONE;}
                break;
        }
        if (state == DONE) break;
    }
    if (state != DONE) return -1; // no freq found. Sad.

    // x2 is our observed min, x1 and x3 lie to either side. We are biasing to the center and scaling our tau so we can operate without floats
    int x1,x2,x3,y1,y2,y3;
    // warning: we're not handling edge-cases here. That's a little risky!
    x2 = 0;
    y2 = loc_min_val;
    x1 = -TAU_INTERP_SCALAR;
    y1 = corrs[loc_min_tau-1];
    x3 = +TAU_INTERP_SCALAR;
    y3 = corrs[loc_min_tau+1];

    // delta y between y1,y2 and y3,y2. It **should** be the case that both y1 and y3 are larger than y2
    int a,b;
    a = y1 - y2;
    b = y3 - y2;

    // keep in mind: our new tau is our "true tau" scaled by our interpolation scalar. Scaling back down would round it back to loc_min_tau
    int tau_offset = (TAU_INTERP_SCALAR * (a - b)) / ( 2 * (a+b + 1));
    int interp_tau = loc_min_tau*TAU_INTERP_SCALAR + tau_offset;

    // f = 1/tau
    // itau = tau*scalar
    // f = scalar / itau
    // F = FS * scalar / itau
    int freq = (s->sample_rate) / (interp_tau);
    freq *= TAU_INTERP_SCALAR;
    return freq;
}

#define MEAN_SQUARE_SAFETY_SHIFTER 8
uint32_t get_mean_square_volume(FREQ_ANALYZER_T *s) {
    uint32_t mean = 0;
    for(int i = 0; i<s->buff_size; i++) {
        mean += s->audio_buffer[i];
        // max size of item in audio buffer for 12-bit ADC is 4096. uint32_t max is 1.048 million times that. We should be good without overflow
    }
    mean = mean/s->buff_size;
    int mean_diff_square;
    for(int i = 0; i<s->buff_size; i++) {
        int val = (int) (s->audio_buffer[i]);
        mean_diff_square +=  (int)(mean - val)*(int)(mean - val) / MEAN_SQUARE_SAFETY_SHIFTER;
        // max difference from mean is about 4096. uint32_t max is only 256 times 4096*4096. Let's divide the diff squared by 8 to be safe, and have a max safe audio buff length of 2048
        // in reality, we're likely completely fine
    }
    mean_diff_square = MEAN_SQUARE_SAFETY_SHIFTER * mean_diff_square/ s->buff_size;
    return (uint32_t)mean_diff_square;
}

// TODO: optimize the ternary ops in the second loop by replacing with bit-twiddling optimizations
uint32_t get_peak_volume(FREQ_ANALYZER_T *s) {
    int mean = 0;
    for (int i = 0; i < s->buff_size; i++) {
        mean += (int)s->audio_buffer[i];
        // max size of item in audio buffer for 12-bit ADC is 4096. uint32_t max is 1.048 million times that. We should be good without overflow
    }
    mean = mean / s->buff_size;

    // "shift-amount"
    //int sa = sizeof(int)*8 - 1;

    int peak = 0;
    for(int i = 0; i<s->buff_size; i++) {
        int diff = (int)(mean) - (int)(s->audio_buffer[i]);
        diff = (diff > 0) ? diff : -diff;
        peak = (peak > diff) ? peak : diff;
    }
    return (uint32_t)peak;
}





// take a frequency input and output the midi pitch ( C0 = 0 )
// Return values:
//       -2: frequency positive but too low
//       -1: frequency is zero
int frequency_to_pitch( int freq) {
    if(freq == 0) return -1;
    else if(freq < PITCH_FREQS[0]) return -2;

    int pitch = 0;

    // divide frequency by 2 until we get to the range of acceptable frequencies
    while(freq > PITCH_FREQS[11]) {freq >>= 1; pitch += 12;}

    //iterate through list of frequencies and find the minimum
    // note: would a binary search be faster? Yes. How much time does this take? Not enough to matter.


    //arbitrary for code density
    int min_diff = 100;
    int ii = -1;
    for( int i =0; i<12; i++) {
        int diff = PITCH_FREQS[i] - freq;
        diff = (diff < 0 ) ? diff * -1 : diff; // absolute value
        if(min_diff > diff) {
            min_diff = diff;
            ii = i;
        }
    }
    if(ii == -1) return -3;

    pitch += ii;

    return pitch;

}


const char print_note_strings[12][3] = {
     "C\0","C#\0", "D\0","D#\0", "E\0","F\0","F#\0", "G\0","G#\0", "A\0","A#\0", "B\0"
};
void print_note(int pitch) {
    if(pitch < 1) printf("NOTE: Bad print_note() input...\n");
    else printf("NOTE: %s  (%d)\n",print_note_strings[pitch%12], pitch/12);

}



